# 服务测试与开发工作流程

## 任务描述
启动 Go 服务，根据用户指令完成开发任务或修复问题，通过测试验证结果，迭代直到目标达成。

## 工作流程

### Step 1: 启动目标服务
调用 `start_process` 工具启动服务进程：

**参数**:
- `command`: `"go run ."`
- `process_name`: `"test"`
- `work_dir`: `"d:/code/phgo"`
- `health_check_url`: `"http://localhost:8081/server"`

**注意事项**:
- 等待健康检查通过后再进行下一步
- 如果启动失败，记录错误信息但继续执行（可能需要检查端口占用等问题）

---

### Step 2: 理解用户需求并分析任务

#### 2.1 任务类型识别
从用户指令中识别任务类型：

**类型 A: 测试验证类**
- 特征：包含"测试"、"检查"、"验证"等词汇
- 示例："测试 GET /api/user?id=1"
- 行为：直接发送请求，验证结果

**类型 B: 问题修复类**
- 特征：包含"修复"、"解决"、"报错"、"异常"等词汇，或描述了错误现象
- 示例："修复 /api/login 返回 500 错误"
- 行为：分析错误 → 定位问题 → 修复代码 → 测试验证

**类型 C: 功能开发类**
- 特征：包含"添加"、"实现"、"新增"、"开发"等词汇
- 示例："添加一个删除用户的接口 DELETE /api/user/:id"
- 行为：分析需求 → 编写代码 → 测试验证 → 迭代优化

**类型 D: 修改调整类**
- 特征：包含"修改"、"调整"、"更改"、"优化"等词汇
- 示例："修改 /api/user 的返回格式，增加 email 字段"
- 行为：理解改动 → 修改代码 → 测试验证

#### 2.2 提取关键信息
- **目标 API/功能**: 具体的接口或功能点
- **请求参数**: URL 路径、查询参数、请求体、请求头
- **预期行为**: 期望的响应内容或功能表现
- **约束条件**: 特殊要求或限制

---

### Step 3: 执行任务

#### 3.1 对于类型 A（测试验证类）

**步骤**:
1. 解析 URL 和请求参数
2. 调用 `request_with_logs` 发送请求
3. 分析响应和日志
4. 输出测试结果

#### 3.2 对于类型 B/C/D（开发/修复类）

**阶段 1: 代码分析**
1. 使用 `Read` 工具阅读相关文件
2. 理解现有代码结构
3. 定位需要修改的位置

**阶段 2: 代码实现/修改**
1. 根据任务类型采取不同策略：

   **修复问题 (B)**:
   - 分析错误日志
   - 定位根本原因
   - 修复代码错误
   - 保持最小化修改

   **开发功能 (C)**:
   - 设计接口结构
   - 实现业务逻辑
   - 添加必要的依赖
   - 保持代码风格一致

   **调整修改 (D)**:
   - 理解改动范围
   - 修改相关代码
   - 确保兼容性

2. 使用 `Edit` 工具进行精确修改
3. 如果需要新增文件，使用 `Write` 工具创建

**阶段 3: 测试验证**
1. **重启服务**: 回到 Step 1 重新启动服务（确保新代码生效）
2. **发送请求**: 调用 `request_with_logs` 测试修改后的功能
3. **收集结果**: 获取响应和日志

---

### Step 4: 验证结果并判断

#### 4.1 判断标准

**✅ 成功标准**:
1. **HTTP 层面**:
   - 状态码为 2xx（200-299）
   - 响应头格式正确

2. **功能层面**:
   - 响应内容符合预期
   - 数据格式正确（如 JSON 结构正确）
   - 业务逻辑正确（如数据被正确创建/更新/删除）

3. **日志层面**:
   - 无错误关键字（`error`, `panic`, `fatal`, `exception`）
   - 无未处理的异常
   - 日志输出符合预期流程

4. **服务层面**:
   - 服务运行稳定
   - 无内存泄漏或资源占用异常
   - 健康检查通过

**❌ 失败标准（任一条件满足）**:
1. **HTTP 层面**:
   - 状态码为 4xx 或 5xx
   - 响应格式错误

2. **功能层面**:
   - 响应内容不符合预期
   - 数据缺失或错误
   - 业务逻辑错误

3. **日志层面**:
   - 包含错误关键字
   - 有堆栈追踪信息
   - 服务崩溃

4. **服务层面**:
   - 服务无法启动
   - 进程意外退出
   - 健康检查失败

#### 4.2 决策分支
```
IF 验证成功 THEN
    → 转到 Step 5（输出结果并结束）
ELSE IF 验证失败 AND 尝试次数 < 5 THEN
    → 转到 Step 3（分析问题 → 修改代码 → 重新测试）
ELSE（验证失败 AND 尝试次数 >= 5）
    → 转到 Step 6（输出失败信息并结束）
END IF
```

---

### Step 5: 输出成功结果

```
✅ 任务完成

任务类型: {测试验证 / 问题修复 / 功能开发 / 代码调整}

执行详情:
{根据任务类型输出不同信息}

测试验证类:
- 请求 URL: {url}
- 请求方法: {method}
- 请求参数: {params}
- 响应状态码: {status}
- 响应内容: {response body}

问题修复类:
- 问题描述: {原始问题}
- 错误原因: {根本原因}
- 修复内容:
  - 修改文件: {file path}
  - 修改位置: {line number}
  - 修改说明: {what changed}
- 测试结果: {test passed}

功能开发类:
- 需求描述: {user requirement}
- 实现方案: {implementation approach}
- 新增/修改文件:
  - {file path}: {change description}
- 测试验证:
  - 测试用例: {test case}
  - 测试结果: {test passed}

代码调整类:
- 调整内容: {what changed}
- 影响范围: {affected areas}
- 测试结果: {test passed}

服务日志:
{相关日志片段}
```

---

### Step 6: 输出失败结果

```
❌ 任务失败（超过最大尝试次数）

任务类型: {任务类型}
尝试次数: 5

问题描述:
{当前存在的问题和错误现象}

错误详情:
- HTTP 状态码: {status}
- 响应内容: {response body}
- 错误日志: {error logs}

尝试过程:
{列出已尝试的修复方案和结果}

建议:
{给出手动排查和解决的建议}

可能的原因:
1. {可能原因 1}
2. {可能原因 2}
3. {可能原因 3}
```

---

## 重要注意事项

### 1. 任务理解
- **不明确时先询问**: 如果用户指令模糊，先向用户确认需求
- **确认参数**: 缺少必要参数时，向用户询问
- **理解业务**: 不仅要实现功能，还要理解业务场景

### 2. 代码操作规范
- **先读后写**: 修改前必须先用 `Read` 读取文件
- **精确匹配**: `Edit` 工具的 `old_string` 必须精确匹配
- **保持风格**: 遵循现有代码的命名、缩进、注释风格
- **最小化修改**: 只修改必要的代码，不要重构无关部分

### 3. 开发最佳实践
- **功能开发**:
  - 设计清晰的 API 接口
  - 实现必要的输入验证
  - 添加适当的错误处理
  - 保持代码可维护性

- **问题修复**:
  - 找到根本原因，不要只修复症状
  - 考虑修复可能带来的副作用
  - 确保修复不引入新问题

- **代码调整**:
  - 评估改动的影响范围
  - 确保向后兼容（如需要）
  - 测试相关功能是否正常

### 4. 测试验证要点
- **功能测试**: 验证功能是否按预期工作
- **边界测试**: 测试边界情况和异常输入
- **日志检查**: 仔细检查日志中的错误和警告
- **服务稳定性**: 确保服务运行正常，无内存泄漏

### 5. 迭代优化策略
- **每次一个问题**: 不要一次尝试修复多个问题
- **记录变化**: 记录每次修改的内容和原因
- **验证效果**: 修改后立即测试验证
- **避免重复**: 如果同样的错误反复出现，调整修复策略

### 6. 循环控制
- **最大迭代次数**: 5 次
- **何时退出循环**:
  - 功能正常工作
  - 达到最大尝试次数
  - 用户确认停止
- **避免无限循环**: 确保每次迭代都有进展

---

## 示例场景

### 示例 1: 测试验证
**用户输入**: "测试 GET /api/user?id=1"

**执行流程**:
1. 识别为类型 A（测试验证类）
2. 启动服务
3. 发送 GET 请求到 `/api/user?id=1`
4. 检查响应和日志
5. 输出测试结果

### 示例 2: 问题修复
**用户输入**: "修复 /api/login 接口，现在返回 500 错误"

**执行流程**:
1. 识别为类型 B（问题修复类）
2. 启动服务
3. 发送测试请求，收集错误日志
4. 分析日志，定位空指针错误
5. 修复代码（添加空值检查）
6. 重启服务，重新测试
7. 验证成功，输出结果

### 示例 3: 功能开发
**用户输入**: "添加一个删除用户的接口 DELETE /api/user/:id"

**执行流程**:
1. 识别为类型 C（功能开发类）
2. 启动服务
3. 分析现有代码结构
4. 实现删除用户功能：
   - 添加路由处理
   - 实现删除逻辑
   - 添加参数验证
   - 添加错误处理
5. 重启服务
6. 测试删除接口
7. 发现参数验证有问题
8. 修复参数验证
9. 重启服务，重新测试
10. 验证成功，输出结果

### 示例 4: 代码调整
**用户输入**: "修改 /api/user 的返回格式，增加 email 和 phone 字段"

**执行流程**:
1. 识别为类型 D（代码调整类）
2. 启动服务
3. 读取用户接口相关代码
4. 修改返回结构体，添加新字段
5. 更新数据库查询逻辑
6. 重启服务
7. 测试接口
8. 验证返回格式正确
9. 输出结果

---

## 快速检查清单

### 开始前检查:
- [ ] 是否正确理解了用户需求？
- [ ] 任务类型是否明确？（测试/修复/开发/调整）
- [ ] 是否有必要的参数信息？

### 代码操作检查:
- [ ] 是否先用 Read 读取了文件？
- [ ] 修改是否保持了代码风格？
- [ ] 是否只修改了必要的部分？
- [ ] 是否考虑了边界情况？

### 测试验证检查:
- [ ] HTTP 状态码是否正确？
- [ ] 响应内容是否符合预期？
- [ ] 日志中是否有错误？
- [ ] 是否测试了正常和异常情况？

### 循环迭代检查:
- [ ] 当前是第几次尝试？
- [ ] 每次迭代是否有进展？
- [ ] 是否需要调整策略？
- [ ] 是否达到了最大尝试次数？

### 输出结果检查:
- [ ] 是否清晰描述了任务完成情况？
- [ ] 是否提供了足够的测试结果？
- [ ] 是否列出了修改的内容？
- [ ] 日志信息是否完整？

---

## 总结

这个工作流程的核心思想是：**理解需求 → 开发/修复 → 测试验证 → 迭代优化**

**关键能力**:
1. **任务识别**: 准确识别不同类型的任务
2. **代码理解**: 快速理解现有代码结构
3. **精确修改**: 使用工具进行精确的代码修改
4. **测试验证**: 通过请求和日志验证功能
5. **迭代优化**: 不断测试和改进直到目标达成
6. **清晰输出**: 提供清晰的执行结果和修改说明

**工作原则**:
- **理解优先**: 不确定时先询问，不要猜测
- **最小化修改**: 只做必要的改动
- **持续验证**: 每次修改后立即测试
- **清晰沟通**: 提供清晰的进度和结果说明
- **质量保证**: 确保代码质量和功能正确性

记住：目标是**高效地完成用户的开发任务**，无论是修复问题、开发新功能，还是调整代码，都要以用户需求为导向，通过测试验证确保质量。
